<!DOCTYPE html>
<html>
    <head>
        <title>Preface</title>
    </head>
    <body>
        <section id="preface">
        <h1>Preface</h1>
            <p>In the spring of 1999 I flew to Chicago to consult on a project being done byThoughtWorks, a small but rapidly growing application development company.The project was one of those ambitious enterprise application projects: a backend leasing system. Essentially it deals with everything that happens to a leaseafter you’ve signed on the dotted line: sending out bills, handling someoneupgrading one of the assets on the lease, chasing people who don’t pay theirbills on time, and figuring out what happens when someone returns the assetsearly. That doesn’t sound too bad until you realize that leasing agreements areinfinitely varied and horrendously complicated. The business “logic” rarely fitsany logical pattern, because, after all, it’s written by business people to capturebusiness, where odd small variations can make all the difference in winning adeal. Each of those little victories adds yet more complexity to the system.</p> 
            <p>That’s the kind of thing that gets me excited: how to take all that complexityand come up with a system of objects that can make the problem more tractable. Indeed, I believe that the primary benefit of objects is in making complexlogic tractable. Developing a good Domain Model (116) for a complex businessproblem is difficult but wonderfully satisfying.</p> 
            <p>Yet that’s not the end of the problem. Our domain model had to be persistedto a database, and, like many projects, we were using a relational database. Wealso had to connect this model to a user interface, provide support to allowremote applications to use our software, and integrate our software with thirdparty packages. All of this on a new technology called J2EE, which nobody inthe world had any real experience in using.</p> 
            <p>Even though this technology was new, we did have the benefit of experience.I’d been doing this kind of thing for ages with C++, Smalltalk, and CORBA.Many of the ThoughtWorkers had a lot of experience with Forte. We alreadyhad the key architectural ideas in our heads, and we just had to figure out howto apply them to J2EE. Looking back on it three years later, the design is notperfect but it has stood the test of time pretty damn well.</p> 
            <p>That’s the kind of situation this book was written for. Over the years I’veseen many enterprise application projects. These projects often contain similardesign ideas that have proven effective in dealing with the inevitable complexitythat enterprise applications possess. This book is a starting point to capturethese design ideas as patterns.</p> 
            <p>The book is organized in two parts, with the first part a set of narrative chapters on a number of important topics in the design of enterprise applications.These chapters introduce various problems in the architecture of enterprise applications and their solutions. However, they don’t go into much detail on thesesolutions. The details of the solutions are in the second part, organized as patterns. These patterns are a reference, and I don’t expect you to read them cover tocover. My intention is that you read the narrative chapters in Part 1 from start tofinish to get a broad picture of what the book covers; then you dip into the patterns chapters of Part 2 as your interest and needs drive you. Thus, the book is ashort narrative book and a longer reference book combined into one.</p> 
            <p>This is a book on enterprise application design. Enterprise applications areabout the display, manipulation, and storage of large amounts of often complexdata and the support or automation of business processes with that data.Examples include reservation systems, financial systems, supply chain systems,and many others that run modern business. Enterprise applications have theirown particular challenges and solutions, and they are different from embeddedsystems, control systems, telecoms, or desktop productivity software. Thus, ifyou work in these other fields, there’s nothing really in this book for you (unlessyou want to get a feel for what enterprise applications are like.) For a generalbook on software architecture, I’d recommend [POSA].</p> 
            <p>There are many architectural issues in building enterprise applications. I’mafraid this book can’t be a comprehensive guide to them. In building softwareI’m a great believer in iterative development. At the heart of iterative development is the notion that you should deliver software as soon as you have something useful to the user, even if it’s not complete. Although there are manydifferences between writing a book and writing software, this notion is one thatI think the two share. That said, this book is an incomplete but (I trust) usefulcompendium of advice on enterprise application architecture. The primary topics I talk about are</p>
            <ul>
                <li>Layering of enterprise applications</li>
                <li>Structuring domain (business) logic</li>
                <li>Structuring a Web user interface</li>
                <li>Linking in-memory modules (particularly objects) to a relational database</li>
                <li>Handling session state in stateless environments</li>
                <li>Principles of distribution</li>
            </ul>
            <p>The list of things I don’t talk about is rather longer. I really fancied writingabout organizing validation, incorporating messaging and asynchronous communication, security, error handling, clustering, application integration, architectural refactoring, structuring rich-client user interfaces, among other topics.However, because of space and time constraints and lack of cogitation, youwon’t find them in this book. I can only hope to see some patterns for this workin the near future. Perhaps I’ll do a second volume someday and get into thesetopics, or maybe someone else will fill these and other gaps.</p> 
            <p>Of these, message-based communication is a particularly big issue. Peoplewho are integrating multiple applications are increasingly making use of asynchronous message-based communication approaches. There’s much to be saidfor using them within an application as well.</p> 
            <p>This book is not intended to be specific for any particular software platform.I first came across these patterns while working with Smalltalk, C++, andCORBA in the late ’80s and early ’90s. In the late ’90s I started to do extensivework in Java and found that these patterns applied well to both early Java/CORBA systems and later J2EE-based work. More recently I’ve been doingsome initial work with Microsoft’s .NET platform and find the patterns applyagain. My ThoughtWorks colleagues have also introduced their experiences,particularly with Forte. I can’t claim generality across all platforms that haveever been or will be used for enterprise applications, but so far these patternshave shown enough recurrence to be useful.</p> 
            <p>I have provided code examples for most of the patterns. My choice of language for them is based on what I think most readers are likely to be able to readand understand. Java is a good choice here. Anyone who can read C or C++ canread Java, yet Java is much less complex than C++. Essentially most C++ programmers can read Java but not vice versa. I’m an object bigot, so I inevitablylean to an OO language. As a result, most of the code examples are in Java. As Iwas working on the book, Microsoft started stabilizing its .NET environment,and its C# language has most of the same properties as Java for an author. So Idid some of the code examples in C# as well, although that introduced some risksince developers don’t have much experience with .NET and so the idioms forusing it well are less mature. Both are C-based languages, so if you can read oneyou should be able to read both, even if you aren’t deeply into that language orplatform. My aim was to use a language that the largest amount of softwaredevelopers can read, even if it’s not their primary or preferred language. (Myapologies to those who like Smalltalk, Delphi, Visual Basic, Perl, Python, Ruby,COBOL, or any other language. I know you think you know a better languagethan Java or C#. All I can say is I do, too!) and explanation of the ideas in thepatterns. They aren’t canned solutions; in all cases you’ll need to do a fair bit ofwork to fit them into your application. Patterns are useful starting points, butthey are not destinations.</p> 
            <p>The examples are there for inspiration and explanation of the ideas in the patterns. They aren’t canned solutions; in all cases you’ll need to do a fair bit of work to fit them into your application. Patterns are useful starting points, but they are not destinations.</p>
        </section>
        
        <section id="who-this-book-is-for">
        <hr>
        <h4>Who This Book Is For</h4>
            <p>I’ve written this book for programmers, designers, and architects who arebuilding enterprise applications and who want to improve either their understanding of architectural issues or their communication about them.</p>
            <p>I’m assuming that most of my readers will fall into two groups: those withmodest needs who are looking to build their own software and readers withmore demanding needs who will be using a tool. For those of modest needs, myintention is that these patterns should get you started. In many areas you’ll needmore than the patterns will give you, but I’ll provide you more of a headstart inthis field than I got. For tool users I hope this book will give you some idea ofwhat’s happening under the hood and also help you choose which of the toolsupported patterns to use. Using, say, an object-relational mapping tool stillmeans that you have to make decisions about how to map certain situations.Reading the patterns should give you some guidance in making the choices.</p> 
            <p>There is a third category; those with demanding needs who want to build theirown software. The first thing I’d say here is to look carefully at using tools. I’veseen more than one project get sucked into a long exercise at building frameworks, which wasn’t what the project was really about. If you’re still convinced,go ahead. Remember in this case that many of the code examples in this book aredeliberately simplified to help understanding, and you’ll find you’ll need to do alot tweaking to handle the greater demands you face.</p> 
            <p>Since patterns are common solutions to recurring problems, there’s a goodchance that you have already come across some of them. If you’ve been working in enterprise applications for a while, you may well know most of them. I’mnot claiming to present anything new in this book. Indeed, I claim the opposite—this is a book of (for our industry) old ideas. If you’re new to this field, Ihope the book will help you learn about these techniques. If you’re familiarwith the techniques, I hope the book will help you communicate and teachthem to others. An important part of patterns is trying to build a commonvocabulary, so you can say that this class is a Remote Facade (388) and otherdesigners will know what you mean.</p>
        </section>
        
        <section id="acknowledgments">
        <hr>
        <h4>Acknowledgments</h4>
            <p>As with any book, what’s written here has a great deal to do with the many people who have worked with me in various ways over the years. Lots of people have helped in lots of ways. Often I don’t recall important things people said that went into this book, but I can acknowledge those contributions I do remember.</p>
            <p>I’ll start with my contributors. David Rice, a colleague of mine at ThoughtWorks, has made a huge contribution—a good tenth of the book. As we worked hard to hit the deadline (while he was also supporting a client), we had several late-night instant message conversations where he confessed to finally seeing why writing a book is both so hard and so compulsive.</p>
            <p>Matt Foemmel is another ThoughtWorker, and although the Arctic will need air conditioning before he writes prose for fun, he’s been a great contributor of code examples (as well as a very succinct critic of the book.) I was pleased that Randy Stafford contributed Service Layer (133) as he’s been such a strong advocate for it. I’d also like to thank Edward Hieatt and Rob Mee for their contribution, which arose from Rob’s noticing a gap while he was doing his review of the text. He became my favorite reviewer: Not only does he notice something missing, he helps write a section to fix it!</p>
            <p>As usual, I owe more than I can say to my first-class panel of official reviewers:</p>
            <table style="width:20%">
                <tr>
                    <td>John Brewer</td>
                    <td>Rob Mee</td> 
                </tr>
                <tr>
                    <td>Kyle Brown</td>
                    <td>Gerard Meszaros</td>
                </tr>
                <tr>
                    <td>Jens Coldewey</td>
                    <td>Dirk Riehle</td>
                </tr>
                <tr>
                    <td>John Crupi</td>
                    <td>Randy Stafford</td>                     
                </tr>
                <tr>
                    <td>Leonard Fenster</td>
                    <td>David Siegel</td>                     
                </tr>
                <tr>
                    <td>Alan Knight</td>
                    <td>Kai Yu</td>                     
                </tr>
            </table>
            <p>I could almost list the ThoughtWorks telephone directory here, for so many of my colleagues have helped this project by talking over their designs and experiences with me. Many patterns formed in my mind because I had the opportunity to talk with the many talented designers we have, so I have little choice but to thank the whole company.</p>
            <p>Kyle Brown, Rachel Reinitz, and Bobby Woolf have gone out of their way to have long and detailed review sessions with me in North Carolina. Their finetooth comb has injected all sorts of wisdom, not including this particularly heinous mixed metaphor. In particular I’ve enjoyed several long telephone calls with Kyle that contributed more than I can list.</p>
            <p>Early in 2000 I prepared a talk for Java One with Alan Knight and Kai Yu that was the earliest genesis of this material. As well as thanking them for their help in that, I should also thank Josh Mackenzie, Rebecca Parsons, and Dave Rice for helping me refine these talks, and the ideas, later on. Jim Newkirk did a great deal in helping me get used to the new world of .NET.</p>
            <p>I’ve learned a lot from the many people working in this field with whom I’ve had good conversations and collaborations. In particular I’d like to thank Colleen Roe, David Muirhead, and Randy Stafford for sharing their work on the Foodsmart example system at Gemstone. I’ve also had great conversations at the Crested Butte workshop that Bruce Eckel has hosted and must thank all the people who attended that event in the last couple of years. Joshua Kerievsky didn’t have time to do a full review, but he was an excellent patterns consultant.</p>
            <p>As usual, I had the remarkable help of the UIUC reading group with their unique brand of no-holds-barred audio reviews. My thanks to: Ariel Gertzenstein, Bosko Zivaljevic , Brad Jones, Brian Foote, Brian Marick, Federico Balaguer, Joseph Yoder, John Brant, Mike Hewner, Ralph Johnson, and Weerasak Witthawaskul.</p>
            <p>Dragos Manolescu, an ex-UIUC hitman, got his own group together to give me feedback. My thanks to Muhammad Anan, Brian Doyle, Emad Ghosheh, Glenn Graessle, Daniel Hein, Prabhaharan Kumarakulasingam, Joe Quint, John Reinke, Kevin Reynolds, Sripriya Srinivasan, and Tirumala Vaddiraju.</p>
            <p>Kent Beck has given me more good ideas than I can remember. But I do remember that he came up with the name for Special Case (496). Jim Odell was responsible for getting me into the world of consulting, teaching, and writing—no acknowledgment will ever do his help justice.</p>
            <p>As I was writing this book, I put drafts on the Web. During this time many people sent me e-mails pointing out problems, asking questions, or talking about alternatives. These people include Michael Banks, Mark Bernstein, Graham Berrisford, Bjorn Beskow, Bryan Boreham, Sean Broadley, Peris Brodsky, Paul Campbell, Chester Chen, John Coakley, Bob Corrick, Pascal Costanza, Andy Czerwonka, Martin Diehl, Daniel Drasin, Juan Gomez Duaso, Don Dwiggins, Peter Foreman, Russell Freeman, Peter Gassmann, Jason Gorman, Dan Green, Lars Gregori, Rick Hansen, Tobin Harris, Russel Healey, Christian Heller, Richard Henderson, Kyle Hermenean, Carsten Heyl, Akira Hirasawa, Eric Kaun, Kirk Knoernschild, Jesper Ladegaard, Chris Lopez, Paolo Marino, Jeremy Miller, Ivan Mitrovic, Thomas Neumann, Judy Obee, Paolo Parovel, Trevor Pinkney, Tomas Restrepo, Joel Rieder, Matthew Roberts, Stefan Roock, Ken Rosha, Andy Schneider, Alexandre Semenov, Stan Silvert, Geoff Soutter, Volker Termath, Christopher Thames, Volker Turau, Knut Wannheden, Marc Wallace, Stefan Wenig, Brad Wiemerslage, Mark Windholtz, Michael Yoon.</p>
            <p>There are many others who gave input whose names I either never knew or can’t remember, but my thanks is no less heartfelt.</p>
            <p>My biggest thanks is, as ever, to my wife Cindy, whose company I appreciate much more than anyone can appreciate this book</p>
        </section>
        <hr>
        <h4>Colophon</h4>
        <section id="colophon">
            <p>This is the first book that I wrote using XML and related technologies. Themaster text was written as a series of XML documents using trusty TextPad. Ialso used a home-grown DTD. While I was working I used XSLT to generatethe web pages for the HTML site. For the diagrams I relied on my old friendVisio using Pavel Hruby’s wonderful UML templates (much better than thosethat come with the tool. I have a link on my Web site if you want them.) I wrotea small program that automatically imported the code examples into the out-put, which saved me from the usual nightmare of code cut and paste. For myfirst draft I tried XSL-FO with Apache FOP. At the time it wasn’t quite up to thejob, so for later work I wrote scripts in XSLT and Ruby to import the text into FrameMaker.</p>
            <p>I used several open source tools while working on this book—in particular,JUnit, NUnit, ant, Xerces, Xalan, Tomcat, Jboss, Ruby, and Hsql. My thanks tothe many developers of these tools. There was also a long list of commercialtools. In particular, I relied on Visual Studio for .NET and on IntelliJ’s wonder-ful Idea—the first IDE that’s excited me since Smalltalk—for Java.The book was acquired for Addison Wesley by Mike Hendrickson who,assisted by Ross Venables, has supervised its publication. I started work on themanuscript in November 2000 and released the final draft to production inJune 2002. As I write this, the book is due for release in November 2002 at OOPSLA.</p>
            <p>Sarah Weaver was the production editor, coordinating the editing, composi-tion, proofreading, indexing, and production of final files. Dianne Wood wasthe copy editor, carrying out the tricky job of cleaning up my English withoutintroducing any untoward refinement. Kim Arney Mulcahy composed the bookinto the design you see here, cleaned up the diagrams, set the text in Sabon, andprepared the final Framemaker files for the printer. The text design is based onthe format we used for Refactoring. Cheryl Ferguson proofread the pages andferreted out any errors that had slipped through the cracks. Irv Hershman pre-pared the index.</p>
            <h4>About the Cover Picture</h4>
            <p>During the couple of years I spent writing this book a more significant construc-tion project was going on in Boston. The Leonard P. Zakim Bunker Hill Bridge(try fitting that name on a road sign) will replace the ugly double-decker thatnow carries Interstate 93 over the Charles River. The Zakim bridge is a cable-stayed bridge, a style that hasn’t been widely used in the U.S. so far, but is verypopular in Europe. The Zakim bridge isn’t particularly long, but it is theworld’s widest cable-stayed bridge and also the first U.S. cable-stayed bridge tohave an asymmetric design. It’s a very beautiful bridge, but that doesn’t stop mefrom teasing Cindy about Henry Petroski’s conjecture that we are due for amajor failure in a cable-stayed bridge soon.</p>
            <p>Martin Fowler, Melrose, Massachusetts, August 2002</p>
            <a href="http://martinfowler.com">http://martinfowler.com</a>
        </section>
    </body>
</html>